  (* encode an option *)
    fun encodeOption encFn (buf, NONE) = ASDLPickle.encodeTag8(buf, 0w0)
      | encodeOption encFn (buf, SOME obj) = (
          ASDLPickle.encodeTag8(buf, 0w1);
          encFn(buf, obj))
  (* decode an option *)
    fun decodeOption decFn slice = (case ASDLPickle.decodeTag8 slice
           of (0w0, slice) => (NONE, slice)
            | (0w1, slice) => let val (obj, slice) = decFn in (SOME obj, slice) end
            | _ => raise ASDL.DecodeError
          (* end case *))
  (* encode a list of values as a sequence *)
    fun encodeSeq encFn (buf, xs) = let
          fun encode [] = ()
            | encode (x::xr) = (encFn(buf, x); encode xr)
          in
            ASDLPickle.encodeUInt(buf, Word.fromInt(length xs));
            encode xs
          end
  (* decode a sequence into a sequence of values *)
    fun decodeSeq decFn slice = let
          val (len, slice) = ASDLPickle.decodeUInt slice
          fun decode (0w0, slice, xs) = reverse (xs, [])
            | decode (n, slice, xs) = let
                val (x, slice) = decFn slice
                in
                  decode (n-0w1, slice, x::xs)
                end
          and reverse ([], xs) = xs
            | reverse (x::xr, xs) = reverse (xr, x::xs)
          in
            decode (len, slice, [])
          end
